package edu.colorado.csci3155.project1

import org.scalatest.FunSuite

class StackMachineTestRecitation extends FunSuite {

/*-- Example 1: EMPTY INSTRUCTION LIST  --*/
/*-- 
In this example, we shall handle the scenario where the program (list of instructions) 
provided as an input to the StackMachine is Empty. 

The way we would invoke the StackMachine Simulator would be: 

```
    val lst1 = Nil
    val (res, rtStack) = StackMachineEmulator.emulateStackMachine(lst1)

```
So, how would we expect our `StackMachineEmulator` to process this empty List-of-Instruction? 

If you examine the codebase of the function `StackMachineEmulator.emulateStackMachine()` 
in the file `StackMachineEmulator.scala` you will observe the following code:

```
    def emulateStackMachine(instructionList: List[StackMachineInstruction], 
                            opStack: OpStack=Nil, 
                            runtimeStack: RuntimeStack=Nil): (Value, RuntimeStack) = { ... }
```
From this defintion, we understand that the function `StackMachineEmulator.emulateStackMachine()` 
is being invoked with the following parameters: 
```
instructionList = lst1  // Nil
opStack = Nil
runtimeStack = Nil
```

Additionally, we observe the following lines of code in the body of `StackMachineEmulator.emulateStackMachine()`:
```
            /*-- Are we out of instructions to execute --*/
            if (instructionList.isEmpty){
                /*-- output top elt. of operand stack and the runtime stack --*/
                (opStack.head, runtimeStack)
```
Thus, we know that if the instruction list is empty, we expect the function to return a tuple
```
(opStack.head, runtimeStack)
```
But, given that `opStack == Nil`, how would you expect Scala to behave? 

Yes, Scala will thrown a Runtime Exception. 

The Exception that is thrown, will have the following test message: 
```
"head of empty list"
```

We proceed to prepare a test-case, to ensure that when we invoke 
`StackMachineEmulator.emulateStackMachine(lst1)` with `lst1 = Nil`, 
Scala generates a RunTime Exception with the explicit text message ["head of empty list"];

We shall use a mechanism that exists within the package `org.scalatest.FunSuite` that
is called an `intercept[Exception]` to help the test-suite intercept the exception that's 
generated by Scala. For more information please Google-Search `org.scalatest.FunSuite intercept`. 

We proceed to do so as follows: 
--*/


    test("stack machine test 1: Empty Instruction List") {
        val lst1 = Nil
        val thrown = intercept[Exception] {
            val (res, rtStack) = StackMachineEmulator.emulateStackMachine(lst1)
        }
        assert(thrown.getMessage === "head of empty list")
    }

/*-- Example 2: INSTRUCTION LIST = [PopI]  --*/
/*-- 
We now proceed to create a test-case for the scenario where the program( input list of instructions)
contains a single `StackMachineInstruction` , the `PopI` instruction. 

From the definition of `PopI` provided in `NotebookForProject1.ipynb` we have: 
```
PopI: pop off the top element of the operand stack - throw an exception if the stack is empty.
```
Thus, we would have to create a test-case that generates

--*/
    test("stack machine test 2: PopI - when Empty Stack") {
        val lst1 = List(PopI)
        val thrown = intercept[Exception] {
            val (res, rtStack) = StackMachineEmulator.emulateStackMachine(lst1)
        }
        assert(thrown.getMessage === "ErrPopI: PopI on Empty Operand Stack!")
    }
/*-- 
Save the files and compile all using `sbt test`. 
You'd notice that there's 1 test which has passed and 1 test which has failed. 

We shall now proceed to develop the code that shall help to pass this test. 

Proceed to `StackMachineEmulator.scala` and modify the body of `StackMachineEmulator.emulateSingleInstruction()`
to implement the expected functionality i.e.
```
PopI: pop off the top element of the operand stack - throw an exception if the stack is empty.
```
 along with creating the situation where you generate the `RunTimeException` with 
 its associated error message ("ErrPopI: PopI on Empty Operand Stack!").

```
        case PopI => {
            if (stack.isEmpty){
                throw new RuntimeException(s"ErrPopI: PopI on Empty Operand Stack!")
            }else{
                (stack.tail, env)
            }
        }
```
Save the files and compile all using `sbt test`. 
--*/

/*-- Example 3: INSTRUCTION LIST = [PushNumI]    --*/
/*--
We proceed to prepare a test-case for the next instruction `PushNumI`. 
From the definition of `PushNumI` provided in `NotebookForProject1.ipynb` we have: 

```
PushNumI(d): push the value Num(d) onto the operand stack. 
Note that d is a Double precision number whereas the operand stack is one of values.
```
We can evaluate the functioning of `PushNumI` by invoking it as follows: 
```
        val lst1 = List(PushNumI(2.5))
        val (res, rtStack) = StackMachineEmulator.emulateStackMachine(lst1)
```
Based on its description, what would you expect the ouput values `res` and `rtStack` 
to contain? 
We know that `StackMachineEmulator.emulateStackMachine` returns the following types:
```
(Value, RuntimeStack) 
```
Thus, we have `res:Value` and `rtStack:RuntimeStack`. 

Additionally, we would expect `res:Value = Num(2.5)`, but, any arbitrary value `Num(d:Double)` 
could also be generated due to a malfunction of the machine. Thus, to ensure that we 
have correctly functioning implementation, we need to extract the `d:Double` from `res:Value = Num(d)`
and verify that `d:Double == 2.5` !

We shall use the helper function `Num.getDoubleValue` in the file `Value.scala` to help us achieve this goal.

Note that the data-structures get updated in the folloing manner: 

1. At Initialization of `StackMachineEmulator.emulateStackMachine()`
```
instructionList = lst1  // [PushNumI(2.5)]
opStack = Nil
runtimeStack = Nil
```
2. On Execution of PushNumI(2.5)
```
instructionList = Nil
opStack = [Num(2.5)]
runtimeStack = Nil
```
3. On Execution of the following lines of code in the body of `StackMachineEmulator.emulateStackMachine()`:
```
            /*-- Are we out of instructions to execute --*/
            if (instructionList.isEmpty){
                /*-- output top elt. of operand stack and the runtime stack --*/
                (opStack.head, runtimeStack)
```
We obtain the following
```
opStack.head = Num(2.5)
runtimeStack = Nil
```
which gets sent out into the test-case. 

We shall now examine those values by preparing the test-case as follows: 

--*/
    test("stack machine test 3: PushNumI(d:Double)") {
        val lst1 = List(PushNumI(2.5))
        val (res, rtStack) = StackMachineEmulator.emulateStackMachine(lst1)
        
        // assertions to test:: RuntimeStack = [] , OperandStack = [Num(2.5)]
        assert(res.getDoubleValue == 2.5)
        assert(rtStack == Nil)
    }

/*-- Exercise 1:  INSTRUCTION LIST = [PushBoolI]   --*/
/*--
Please proceed to prepare a test-case the next instruction `PushBoolI`. 
Note that's its pretty much similar to the scenario described in `Example 3` above. 
From the definition of `PushBoolI` provided in `NotebookForProject1.ipynb` we have: 
```
PushBoolI(b): push the value Bool(b) onto the operand stack. 
Note that b is a Boolean whereas the operand stack is one of values.
```

--*/
    test("stack machine test 4: PushBoolI(b:Bool)") {
        val lst1 = List(PushBoolI(true))
        val (res, rtStack) = StackMachineEmulator.emulateStackMachine(lst1)
        
        // assertions to test :: RuntimeStack = [] , OperandStack = [Bool(true)]
        assert(res.getBooleanValue == true)
        assert(rtStack == Nil)
    }

/*-- Exercise 2: INSTRUCTION LIST = [PushNumI(d), PopI]   --*/
/*--
Now let's proceed to evaluate the output of the StackMachine, when we have an instruction list
that has more than 1 instruction. Let's begin by considering a sequence of two instructions that 
we handled above. 

```
val lst1 = List(PushNumI(2.5), PopI)
```
Examine the behaviour of the machine as it executes this input list of instructions. 
Additionally, prepare the test-case that shall help you evaluate this functionality. 

--*/
    test("stack machine test 5: PushNumI(d:Double) + PopI") {
        val lst1 = List(PushNumI(2.5), PopI)

        val thrown = intercept[Exception] {
            val (res, rtStack) = StackMachineEmulator.emulateStackMachine(lst1)
            assert(rtStack == Nil)
        }

        // State after Executing:: RuntimeStack = [] , OperandStack = []
        // TODO::  opstack.head is non-existent. 
        // Therefore an exception shall be thrown. 
        assert(thrown.getMessage === "head of empty list")
        
    }

/*-- Example 4: Handling LoadEnv   --*/

/*--
We now proceed to examine one of the instructions that work off the runtimeStack and the operandStack. 
In particular, we focus on the instruction `LoadEnv`. 

From the definition of `LoadEnv` provided in `NotebookForProject1.ipynb` we have: 
```
LoadEnv(identifier): The instruction pops one value v off the operand stack and 
pushes the pair (identifier, v) on the runtime stack.
```

We shall handle the following two test-cases. 
1. A scenario where the operand-stack is Empty, when executing `LoadEnv`. 
2. A scenario where the operand-stack is Non-Empty when executing `LoadEnv`.

 --*/

/*-- Example 4.1: INSTRUCTION LIST = [LoadEnv("x")]   --*/
/*--
When we consider an input list of instructions `lst1 = List(LoadEnv("x"))` being invoked with 
the assumption that `operandStack = Nil & runtimeStack = Nil` in `StackMachineEmulator.emulateStackMachine(lst1)`,
we expect the system to execute the following behaviour:

1. Initialization
```
instructionList = List(LoadEnv("x"))
operandStack = Nil
runtimeStack = Nil
```

2. Execute `LoadEnv("x")` : Pop one value v from the operand-stack.
```
instructionList = Nil
operandStack = Nil
runtimeStack = Nil
```
Since the `operandStack = Nil` we expect Scala to throw a runtimeException.
We can custom-define the expected error to be: "ErrLoadEnv.1: Stack is Empty. Cannot LoadEnv."

The test-case shall be prepared as follows:
--*/
    test("stack machine test 6: Load Env - when Empty") {
        val lst1 = List(LoadEnv("x"))

        // Catch the runtime Exception generated by Scala. 
        val thrown = intercept[Exception] {
            val (_, _) = StackMachineEmulator.emulateStackMachine(lst1)
            
        }
        
        // assertions to test :: RuntimeStack = [] , OperandStack = []
        assert(thrown.getMessage === "ErrLoadEnv.1: Stack is Empty. Cannot LoadEnv.")

    }

/*-- Example 4.2: INSTRUCTION LIST = [PushNumI(2.5), LoadEnv("x")]   --*/
/*--
We shall now examine a scenario where the `OperandStack != Nil` when executing `LoadEnv`.
We do this by evaluating the following program: 
```
lst1 = List(PushNumI(2.5), LoadEnv("x"))
```
in which we first push a numeric-value onto the empty operand stack and then execute `LoadEnv` 
upon that operand-stack. 

We can examine the state of the StackMachine to evolve as follows, when we invoke `StackMachineEmulator.emulateStackMachine(lst1)`: 

1. Initialization: 
```
instructionList = List(PushNumI(2.5), LoadEnv("x"))
operandStack = Nil
runtimeStack = Nil
```
2. Execute `PushNumI(2.5)`
```
instructionList = List( LoadEnv("x"))
operandStack = [Num(2.5)]
runtimeStack = Nil
```
3. Execute `LoadEnv("x")`
```
instructionList = Nil
operandStack = Nil
runtimeStack = [("x", Num(2.5) )]
```
4. Execute `Empty Instruction List` 
```
            /*-- Are we out of instructions to execute --*/
            if (instructionList.isEmpty){
                /*-- output top elt. of operand stack and the runtime stack --*/
                (opStack.head, runtimeStack)
```
We expect scala to throw a runtime-Exception since `opStack.head` will fail when `opStack == Nil`. 
We proceed to prepare the following test case: 
--*/
    test("stack machine test 7: Load Env - when Non-Empty") {
        val lst1 = List(PushNumI(2.5), LoadEnv("x"))

        val thrown = intercept[Exception] {
            val (_, _) = StackMachineEmulator.emulateStackMachine(lst1)
            
            // assertions to test :: RuntimeStack = [("x",Num(2.5))] , OperandStack = []
            //assert(res.getDoubleValue == 2.5)
            //assert(rtStack.head == ("x", Num(2.5)) )
        }
        assert(thrown.getMessage === "head of empty list")

    }

/*-- 
Note that the above test-cases are NOT COMPREHENSIVE
for evaluating the correct functionality of the instruction `LoadEnv`. This is because we make
the assumption that the `operandStack = Nil` and `runtimeStack = Nil`, when we invoke `StackMachineEmulator.emulateStackMachine`.

However, the functionality of `LoadEnv` needs to be examined in all possible contexts where
`operandStack != Nil` and `runtimeStack != Nil`. You may try to develop new test-cases that
address some example scenarios. 
--*/


/*-- Exercise 4: Handling AddI --*/
/*--
From the definition of `AddI` provided in `NotebookForProject1.ipynb` we have: 
```
AddI: pop two values from the stack, if they are numerical values (of the form Num(_)) 
then add them and push the resulting numerical value back to the stack. 
Throw an exception if the stack is empty during any of the pop operations or 
the two values popped off are not both numbers. 
```

Examine different scenarios that need to be addressed, when trying to test 
the functionality of `AddI` instruction. 

1. How many test-scenarios can you identify? 
2. Give examples of input list of instructions that you'd provide to the system, 
with the assumptions that the `operandStack = Nil` and `runtimeStack=Nil`.
3. How would your test-scenarios change, if `operandStack != Nil` and `runtimeStack != Nil`.
Can you create new scenarios that need to be tested? 

--*/

/*-- Exercise 4.1: INSTRUCTION LIST = [PushNumI(2.5), PushNumI(3.5), AddI]   --*/

    test("stack machine test 8: Add 2 numbers. Correct input. ") {
        val lst1 = List(PushNumI(2.5), PushNumI(3.5), AddI)
        val (res, rtStack) = StackMachineEmulator.emulateStackMachine(lst1)
        assert(res.getDoubleValue == 6.0)
        assert(rtStack == Nil )
    }

/*-- Exercise 4.2: INSTRUCTION LIST = [PushNumI(2.5), AddI]   --*/
    test("stack machine test 9: Add 2 numbers. INSUFFICIENT input. ") {
        val lst1 = List(PushNumI(2.5), AddI)

        val thrown = intercept[Exception] {
            val (_, _) = StackMachineEmulator.emulateStackMachine(lst1)
        }

        assert(thrown.getMessage === "ErrAddI.1: Stack of Insufficient size. Cannot AddI.")
    }


/*-- Exercise 4.3: INSTRUCTION LIST = [PushNumI(2.5), PushBoolI(false), AddI]   --*/
    test("stack machine test 10: Add 2 numbers. Incorrect input. ") {
        val lst1 = List(PushNumI(2.5), PushBoolI(false), AddI)

        val thrown = intercept[Exception] {
            val (_, _) = StackMachineEmulator.emulateStackMachine(lst1)
        }

        assert(thrown.getMessage === "ErrAddI.2: Entries in OperandStack of Incorrect DataType. Cannot AddI.")
    }


}
